/** THIS IS AN AUTOMATICALLY GENERATED FILE.  DO NOT MODIFY
 * BY HAND!!
 *
 * Generated by lcm-gen
 *
 * From Source File: /Users/ryan/dev/symforce-zig-build/lcmtypes/symforce_types.lcm
 **/

#include <lcm/lcm_coretypes.h>

#ifndef __sym_type_t_hpp__
#define __sym_type_t_hpp__

#include <array>
#include <ostream>

namespace sym
{

/// Data types that can be stored in a Values object.
class type_t
{
    public:
        enum option_t : int32_t {
            INVALID = 0,
            SCALAR = 1,
            ROT2 = 2,
            ROT3 = 3,
            POSE2 = 4,
            POSE3 = 5,
            UNIT3 = 7,
            DATABUFFER = 6,
            VECTORX = 10,
            VECTOR1 = 11,
            VECTOR2 = 12,
            VECTOR3 = 13,
            VECTOR4 = 14,
            VECTOR5 = 15,
            VECTOR6 = 16,
            VECTOR7 = 17,
            VECTOR8 = 18,
            VECTOR9 = 19,
            MATRIX12 = 20,
            MATRIX13 = 21,
            MATRIX14 = 22,
            MATRIX15 = 23,
            MATRIX16 = 24,
            MATRIX17 = 25,
            MATRIX18 = 26,
            MATRIX19 = 27,
            MATRIX22 = 28,
            MATRIX23 = 29,
            MATRIX24 = 30,
            MATRIX25 = 31,
            MATRIX26 = 32,
            MATRIX27 = 33,
            MATRIX28 = 34,
            MATRIX29 = 35,
            MATRIX32 = 36,
            MATRIX33 = 37,
            MATRIX34 = 38,
            MATRIX35 = 39,
            MATRIX36 = 40,
            MATRIX37 = 41,
            MATRIX38 = 42,
            MATRIX39 = 43,
            MATRIX42 = 44,
            MATRIX43 = 45,
            MATRIX44 = 46,
            MATRIX45 = 47,
            MATRIX46 = 48,
            MATRIX47 = 49,
            MATRIX48 = 50,
            MATRIX49 = 51,
            MATRIX52 = 52,
            MATRIX53 = 53,
            MATRIX54 = 54,
            MATRIX55 = 55,
            MATRIX56 = 56,
            MATRIX57 = 57,
            MATRIX58 = 58,
            MATRIX59 = 59,
            MATRIX62 = 60,
            MATRIX63 = 61,
            MATRIX64 = 62,
            MATRIX65 = 63,
            MATRIX66 = 64,
            MATRIX67 = 65,
            MATRIX68 = 66,
            MATRIX69 = 67,
            MATRIX72 = 68,
            MATRIX73 = 69,
            MATRIX74 = 70,
            MATRIX75 = 71,
            MATRIX76 = 72,
            MATRIX77 = 73,
            MATRIX78 = 74,
            MATRIX79 = 75,
            MATRIX82 = 76,
            MATRIX83 = 77,
            MATRIX84 = 78,
            MATRIX85 = 79,
            MATRIX86 = 80,
            MATRIX87 = 81,
            MATRIX88 = 82,
            MATRIX89 = 83,
            MATRIX92 = 84,
            MATRIX93 = 85,
            MATRIX94 = 86,
            MATRIX95 = 87,
            MATRIX96 = 88,
            MATRIX97 = 89,
            MATRIX98 = 90,
            MATRIX99 = 91,
            ATAN_CAMERA_CAL = 92,
            DOUBLE_SPHERE_CAMERA_CAL = 93,
            EQUIRECTANGULAR_CAMERA_CAL = 94,
            LINEAR_CAMERA_CAL = 95,
            POLYNOMIAL_CAMERA_CAL = 96,
            SPHERICAL_CAMERA_CAL = 97,
        };

    public:
        option_t value;

    public:
        type_t() = default;

        /**
         * Member constructor
         */
        inline constexpr type_t(const option_t& value_arg);

        /**
         * Conversion to int32_t value.
         */
        inline int32_t int_value() const;

        /**
         * Static constructor from int32_t value.  Does not validate the value.
         */
        static inline type_t from_int(int32_t int_value);

        /**
         * Get all values of the enum as a std::array.
         */
        static inline constexpr std::array<option_t, 96> values();

        /**
         * Get const-char pointer of the enum string.
         */
        inline const char* string_value() const;

        /**
         * Encode a message into binary form.
         *
         * @param buf The output buffer.
         * @param offset Encoding starts at thie byte offset into @p buf.
         * @param maxlen Maximum number of bytes to write.  This should generally be
         *  equal to getEncodedSize().
         * @return The number of bytes encoded, or <0 on error.
         */
        inline __lcm_buffer_size encode(void *buf, __lcm_buffer_size offset, __lcm_buffer_size maxlen) const;

        /**
         * Check how many bytes are required to encode this message.
         */
        inline __lcm_buffer_size getEncodedSize() const;

        /**
         * Decode a message from binary form into this instance.
         *
         * @param buf The buffer containing the encoded message.
         * @param offset The byte offset into @p buf where the encoded message starts.
         * @param maxlen The maximum number of bytes to read while decoding.
         * @return The number of bytes decoded, or <0 if an error occured.
         */
        inline __lcm_buffer_size decode(const void *buf, __lcm_buffer_size offset, __lcm_buffer_size maxlen);

        /**
         * Retrieve the 64-bit fingerprint identifying the structure of the message.
         * Note that the fingerprint is the same for all instances of the same
         * message type, and is a fingerprint on the message type definition, not on
         * the message contents.
         */
        constexpr static int64_t getHash();

        using type_name_array_t = const char[7];

        inline static constexpr type_name_array_t* getTypeNameArrayPtr();

        /**
         * Returns "type_t"
         */
        inline static constexpr const char* getTypeName();

        /**
         * Returns "sym"
         */
        inline static constexpr const char * getPackageName();

        // LCM support functions. Users should not call these
        inline __lcm_buffer_size _encodeNoHash(void *buf, __lcm_buffer_size offset, __lcm_buffer_size maxlen) const;
        inline __lcm_buffer_size _getEncodedSizeNoHash() const;
        inline __lcm_buffer_size _decodeNoHash(const void *buf, __lcm_buffer_size offset, __lcm_buffer_size maxlen);
        constexpr static uint64_t _computeHash(const __lcm_hash_ptr *p);
};

constexpr type_t::type_t(
    const type_t::option_t& value_arg
) : value(value_arg) {}

int32_t type_t::int_value() const {
    return static_cast<int32_t>(value);
}

type_t type_t::from_int(int32_t int_value) {
    return type_t(static_cast<option_t>(int_value));
}

__lcm_buffer_size type_t::encode(void *buf, __lcm_buffer_size offset, __lcm_buffer_size maxlen) const
{
    __lcm_buffer_size pos = 0, tlen;
    int64_t hash = (int64_t)getHash();

    tlen = __int64_t_encode_array(buf, offset + pos, maxlen - pos, &hash, 1);
    if(tlen < 0) return tlen; else pos += tlen;

    tlen = this->_encodeNoHash(buf, offset + pos, maxlen - pos);
    if (tlen < 0) return tlen; else pos += tlen;

    return pos;
}

__lcm_buffer_size type_t::decode(const void *buf, __lcm_buffer_size offset, __lcm_buffer_size maxlen)
{
    __lcm_buffer_size pos = 0, thislen;

    int64_t msg_hash;
    thislen = __int64_t_decode_array(buf, offset + pos, maxlen - pos, &msg_hash, 1);
    if (thislen < 0) return thislen; else pos += thislen;
    if (msg_hash != getHash()) return -1;

    thislen = this->_decodeNoHash(buf, offset + pos, maxlen - pos);
    if (thislen < 0) return thislen; else pos += thislen;

    return pos;
}

__lcm_buffer_size type_t::getEncodedSize() const
{
    return 8 + _getEncodedSizeNoHash();
}

constexpr int64_t type_t::getHash()
{
    return _computeHash(NULL);
}

constexpr type_t::type_name_array_t* type_t::getTypeNameArrayPtr() {
    return &"type_t";
}

constexpr const char* type_t::getTypeName()
{
    return *type_t::getTypeNameArrayPtr();
}

constexpr const char * type_t::getPackageName()
{
    return "sym";
}

__lcm_buffer_size type_t::_encodeNoHash(void *buf, __lcm_buffer_size offset, __lcm_buffer_size maxlen) const
{
    __lcm_buffer_size pos = 0, tlen;

    tlen = __int32_t_encode_array(buf, offset + pos, maxlen - pos, reinterpret_cast<const int32_t*>(&this->value), 1);
    if(tlen < 0) return tlen; else pos += tlen;

    return pos;
}

__lcm_buffer_size type_t::_decodeNoHash(const void *buf, __lcm_buffer_size offset, __lcm_buffer_size maxlen)
{
    __lcm_buffer_size pos = 0, tlen;

    tlen = __int32_t_decode_array(buf, offset + pos, maxlen - pos, reinterpret_cast<int32_t*>(&this->value), 1);
    if(tlen < 0) return tlen; else pos += tlen;

    return pos;
}

__lcm_buffer_size type_t::_getEncodedSizeNoHash() const
{
    __lcm_buffer_size enc_size = 0;
    enc_size += __int32_t_encoded_array_size(NULL, 1);
    return enc_size;
}

constexpr uint64_t type_t::_computeHash(const __lcm_hash_ptr *)
{
    uint64_t hash = 0xa6869f09f492d897LL;
    return (hash<<1) + ((hash>>63)&1);
}

inline bool operator==(const type_t& a, const type_t& b)
{
    return a.value == b.value;
}

inline bool operator!=(const type_t& a, const type_t& b)
{
    return !(a == b);
}

inline bool operator<(const type_t& a, const type_t& b)
{
    return a.value < b.value;
}

inline constexpr std::array<type_t::option_t, 96> type_t::values()
{
    return {{
        INVALID,
        SCALAR,
        ROT2,
        ROT3,
        POSE2,
        POSE3,
        UNIT3,
        DATABUFFER,
        VECTORX,
        VECTOR1,
        VECTOR2,
        VECTOR3,
        VECTOR4,
        VECTOR5,
        VECTOR6,
        VECTOR7,
        VECTOR8,
        VECTOR9,
        MATRIX12,
        MATRIX13,
        MATRIX14,
        MATRIX15,
        MATRIX16,
        MATRIX17,
        MATRIX18,
        MATRIX19,
        MATRIX22,
        MATRIX23,
        MATRIX24,
        MATRIX25,
        MATRIX26,
        MATRIX27,
        MATRIX28,
        MATRIX29,
        MATRIX32,
        MATRIX33,
        MATRIX34,
        MATRIX35,
        MATRIX36,
        MATRIX37,
        MATRIX38,
        MATRIX39,
        MATRIX42,
        MATRIX43,
        MATRIX44,
        MATRIX45,
        MATRIX46,
        MATRIX47,
        MATRIX48,
        MATRIX49,
        MATRIX52,
        MATRIX53,
        MATRIX54,
        MATRIX55,
        MATRIX56,
        MATRIX57,
        MATRIX58,
        MATRIX59,
        MATRIX62,
        MATRIX63,
        MATRIX64,
        MATRIX65,
        MATRIX66,
        MATRIX67,
        MATRIX68,
        MATRIX69,
        MATRIX72,
        MATRIX73,
        MATRIX74,
        MATRIX75,
        MATRIX76,
        MATRIX77,
        MATRIX78,
        MATRIX79,
        MATRIX82,
        MATRIX83,
        MATRIX84,
        MATRIX85,
        MATRIX86,
        MATRIX87,
        MATRIX88,
        MATRIX89,
        MATRIX92,
        MATRIX93,
        MATRIX94,
        MATRIX95,
        MATRIX96,
        MATRIX97,
        MATRIX98,
        MATRIX99,
        ATAN_CAMERA_CAL,
        DOUBLE_SPHERE_CAMERA_CAL,
        EQUIRECTANGULAR_CAMERA_CAL,
        LINEAR_CAMERA_CAL,
        POLYNOMIAL_CAMERA_CAL,
        SPHERICAL_CAMERA_CAL,
    }};
}

inline const char* type_t::string_value() const
{
    switch (value) {
        case type_t::INVALID:
            return "INVALID";
        case type_t::SCALAR:
            return "SCALAR";
        case type_t::ROT2:
            return "ROT2";
        case type_t::ROT3:
            return "ROT3";
        case type_t::POSE2:
            return "POSE2";
        case type_t::POSE3:
            return "POSE3";
        case type_t::UNIT3:
            return "UNIT3";
        case type_t::DATABUFFER:
            return "DATABUFFER";
        case type_t::VECTORX:
            return "VECTORX";
        case type_t::VECTOR1:
            return "VECTOR1";
        case type_t::VECTOR2:
            return "VECTOR2";
        case type_t::VECTOR3:
            return "VECTOR3";
        case type_t::VECTOR4:
            return "VECTOR4";
        case type_t::VECTOR5:
            return "VECTOR5";
        case type_t::VECTOR6:
            return "VECTOR6";
        case type_t::VECTOR7:
            return "VECTOR7";
        case type_t::VECTOR8:
            return "VECTOR8";
        case type_t::VECTOR9:
            return "VECTOR9";
        case type_t::MATRIX12:
            return "MATRIX12";
        case type_t::MATRIX13:
            return "MATRIX13";
        case type_t::MATRIX14:
            return "MATRIX14";
        case type_t::MATRIX15:
            return "MATRIX15";
        case type_t::MATRIX16:
            return "MATRIX16";
        case type_t::MATRIX17:
            return "MATRIX17";
        case type_t::MATRIX18:
            return "MATRIX18";
        case type_t::MATRIX19:
            return "MATRIX19";
        case type_t::MATRIX22:
            return "MATRIX22";
        case type_t::MATRIX23:
            return "MATRIX23";
        case type_t::MATRIX24:
            return "MATRIX24";
        case type_t::MATRIX25:
            return "MATRIX25";
        case type_t::MATRIX26:
            return "MATRIX26";
        case type_t::MATRIX27:
            return "MATRIX27";
        case type_t::MATRIX28:
            return "MATRIX28";
        case type_t::MATRIX29:
            return "MATRIX29";
        case type_t::MATRIX32:
            return "MATRIX32";
        case type_t::MATRIX33:
            return "MATRIX33";
        case type_t::MATRIX34:
            return "MATRIX34";
        case type_t::MATRIX35:
            return "MATRIX35";
        case type_t::MATRIX36:
            return "MATRIX36";
        case type_t::MATRIX37:
            return "MATRIX37";
        case type_t::MATRIX38:
            return "MATRIX38";
        case type_t::MATRIX39:
            return "MATRIX39";
        case type_t::MATRIX42:
            return "MATRIX42";
        case type_t::MATRIX43:
            return "MATRIX43";
        case type_t::MATRIX44:
            return "MATRIX44";
        case type_t::MATRIX45:
            return "MATRIX45";
        case type_t::MATRIX46:
            return "MATRIX46";
        case type_t::MATRIX47:
            return "MATRIX47";
        case type_t::MATRIX48:
            return "MATRIX48";
        case type_t::MATRIX49:
            return "MATRIX49";
        case type_t::MATRIX52:
            return "MATRIX52";
        case type_t::MATRIX53:
            return "MATRIX53";
        case type_t::MATRIX54:
            return "MATRIX54";
        case type_t::MATRIX55:
            return "MATRIX55";
        case type_t::MATRIX56:
            return "MATRIX56";
        case type_t::MATRIX57:
            return "MATRIX57";
        case type_t::MATRIX58:
            return "MATRIX58";
        case type_t::MATRIX59:
            return "MATRIX59";
        case type_t::MATRIX62:
            return "MATRIX62";
        case type_t::MATRIX63:
            return "MATRIX63";
        case type_t::MATRIX64:
            return "MATRIX64";
        case type_t::MATRIX65:
            return "MATRIX65";
        case type_t::MATRIX66:
            return "MATRIX66";
        case type_t::MATRIX67:
            return "MATRIX67";
        case type_t::MATRIX68:
            return "MATRIX68";
        case type_t::MATRIX69:
            return "MATRIX69";
        case type_t::MATRIX72:
            return "MATRIX72";
        case type_t::MATRIX73:
            return "MATRIX73";
        case type_t::MATRIX74:
            return "MATRIX74";
        case type_t::MATRIX75:
            return "MATRIX75";
        case type_t::MATRIX76:
            return "MATRIX76";
        case type_t::MATRIX77:
            return "MATRIX77";
        case type_t::MATRIX78:
            return "MATRIX78";
        case type_t::MATRIX79:
            return "MATRIX79";
        case type_t::MATRIX82:
            return "MATRIX82";
        case type_t::MATRIX83:
            return "MATRIX83";
        case type_t::MATRIX84:
            return "MATRIX84";
        case type_t::MATRIX85:
            return "MATRIX85";
        case type_t::MATRIX86:
            return "MATRIX86";
        case type_t::MATRIX87:
            return "MATRIX87";
        case type_t::MATRIX88:
            return "MATRIX88";
        case type_t::MATRIX89:
            return "MATRIX89";
        case type_t::MATRIX92:
            return "MATRIX92";
        case type_t::MATRIX93:
            return "MATRIX93";
        case type_t::MATRIX94:
            return "MATRIX94";
        case type_t::MATRIX95:
            return "MATRIX95";
        case type_t::MATRIX96:
            return "MATRIX96";
        case type_t::MATRIX97:
            return "MATRIX97";
        case type_t::MATRIX98:
            return "MATRIX98";
        case type_t::MATRIX99:
            return "MATRIX99";
        case type_t::ATAN_CAMERA_CAL:
            return "ATAN_CAMERA_CAL";
        case type_t::DOUBLE_SPHERE_CAMERA_CAL:
            return "DOUBLE_SPHERE_CAMERA_CAL";
        case type_t::EQUIRECTANGULAR_CAMERA_CAL:
            return "EQUIRECTANGULAR_CAMERA_CAL";
        case type_t::LINEAR_CAMERA_CAL:
            return "LINEAR_CAMERA_CAL";
        case type_t::POLYNOMIAL_CAMERA_CAL:
            return "POLYNOMIAL_CAMERA_CAL";
        case type_t::SPHERICAL_CAMERA_CAL:
            return "SPHERICAL_CAMERA_CAL";
    }
    return "type_t::<UNKNOWN VALUE>";
}

inline std::ostream& operator <<(std::ostream& s, const type_t::option_t& option)
{
    switch (option) {
        case type_t::INVALID:
            return s << "INVALID";
        case type_t::SCALAR:
            return s << "SCALAR";
        case type_t::ROT2:
            return s << "ROT2";
        case type_t::ROT3:
            return s << "ROT3";
        case type_t::POSE2:
            return s << "POSE2";
        case type_t::POSE3:
            return s << "POSE3";
        case type_t::UNIT3:
            return s << "UNIT3";
        case type_t::DATABUFFER:
            return s << "DATABUFFER";
        case type_t::VECTORX:
            return s << "VECTORX";
        case type_t::VECTOR1:
            return s << "VECTOR1";
        case type_t::VECTOR2:
            return s << "VECTOR2";
        case type_t::VECTOR3:
            return s << "VECTOR3";
        case type_t::VECTOR4:
            return s << "VECTOR4";
        case type_t::VECTOR5:
            return s << "VECTOR5";
        case type_t::VECTOR6:
            return s << "VECTOR6";
        case type_t::VECTOR7:
            return s << "VECTOR7";
        case type_t::VECTOR8:
            return s << "VECTOR8";
        case type_t::VECTOR9:
            return s << "VECTOR9";
        case type_t::MATRIX12:
            return s << "MATRIX12";
        case type_t::MATRIX13:
            return s << "MATRIX13";
        case type_t::MATRIX14:
            return s << "MATRIX14";
        case type_t::MATRIX15:
            return s << "MATRIX15";
        case type_t::MATRIX16:
            return s << "MATRIX16";
        case type_t::MATRIX17:
            return s << "MATRIX17";
        case type_t::MATRIX18:
            return s << "MATRIX18";
        case type_t::MATRIX19:
            return s << "MATRIX19";
        case type_t::MATRIX22:
            return s << "MATRIX22";
        case type_t::MATRIX23:
            return s << "MATRIX23";
        case type_t::MATRIX24:
            return s << "MATRIX24";
        case type_t::MATRIX25:
            return s << "MATRIX25";
        case type_t::MATRIX26:
            return s << "MATRIX26";
        case type_t::MATRIX27:
            return s << "MATRIX27";
        case type_t::MATRIX28:
            return s << "MATRIX28";
        case type_t::MATRIX29:
            return s << "MATRIX29";
        case type_t::MATRIX32:
            return s << "MATRIX32";
        case type_t::MATRIX33:
            return s << "MATRIX33";
        case type_t::MATRIX34:
            return s << "MATRIX34";
        case type_t::MATRIX35:
            return s << "MATRIX35";
        case type_t::MATRIX36:
            return s << "MATRIX36";
        case type_t::MATRIX37:
            return s << "MATRIX37";
        case type_t::MATRIX38:
            return s << "MATRIX38";
        case type_t::MATRIX39:
            return s << "MATRIX39";
        case type_t::MATRIX42:
            return s << "MATRIX42";
        case type_t::MATRIX43:
            return s << "MATRIX43";
        case type_t::MATRIX44:
            return s << "MATRIX44";
        case type_t::MATRIX45:
            return s << "MATRIX45";
        case type_t::MATRIX46:
            return s << "MATRIX46";
        case type_t::MATRIX47:
            return s << "MATRIX47";
        case type_t::MATRIX48:
            return s << "MATRIX48";
        case type_t::MATRIX49:
            return s << "MATRIX49";
        case type_t::MATRIX52:
            return s << "MATRIX52";
        case type_t::MATRIX53:
            return s << "MATRIX53";
        case type_t::MATRIX54:
            return s << "MATRIX54";
        case type_t::MATRIX55:
            return s << "MATRIX55";
        case type_t::MATRIX56:
            return s << "MATRIX56";
        case type_t::MATRIX57:
            return s << "MATRIX57";
        case type_t::MATRIX58:
            return s << "MATRIX58";
        case type_t::MATRIX59:
            return s << "MATRIX59";
        case type_t::MATRIX62:
            return s << "MATRIX62";
        case type_t::MATRIX63:
            return s << "MATRIX63";
        case type_t::MATRIX64:
            return s << "MATRIX64";
        case type_t::MATRIX65:
            return s << "MATRIX65";
        case type_t::MATRIX66:
            return s << "MATRIX66";
        case type_t::MATRIX67:
            return s << "MATRIX67";
        case type_t::MATRIX68:
            return s << "MATRIX68";
        case type_t::MATRIX69:
            return s << "MATRIX69";
        case type_t::MATRIX72:
            return s << "MATRIX72";
        case type_t::MATRIX73:
            return s << "MATRIX73";
        case type_t::MATRIX74:
            return s << "MATRIX74";
        case type_t::MATRIX75:
            return s << "MATRIX75";
        case type_t::MATRIX76:
            return s << "MATRIX76";
        case type_t::MATRIX77:
            return s << "MATRIX77";
        case type_t::MATRIX78:
            return s << "MATRIX78";
        case type_t::MATRIX79:
            return s << "MATRIX79";
        case type_t::MATRIX82:
            return s << "MATRIX82";
        case type_t::MATRIX83:
            return s << "MATRIX83";
        case type_t::MATRIX84:
            return s << "MATRIX84";
        case type_t::MATRIX85:
            return s << "MATRIX85";
        case type_t::MATRIX86:
            return s << "MATRIX86";
        case type_t::MATRIX87:
            return s << "MATRIX87";
        case type_t::MATRIX88:
            return s << "MATRIX88";
        case type_t::MATRIX89:
            return s << "MATRIX89";
        case type_t::MATRIX92:
            return s << "MATRIX92";
        case type_t::MATRIX93:
            return s << "MATRIX93";
        case type_t::MATRIX94:
            return s << "MATRIX94";
        case type_t::MATRIX95:
            return s << "MATRIX95";
        case type_t::MATRIX96:
            return s << "MATRIX96";
        case type_t::MATRIX97:
            return s << "MATRIX97";
        case type_t::MATRIX98:
            return s << "MATRIX98";
        case type_t::MATRIX99:
            return s << "MATRIX99";
        case type_t::ATAN_CAMERA_CAL:
            return s << "ATAN_CAMERA_CAL";
        case type_t::DOUBLE_SPHERE_CAMERA_CAL:
            return s << "DOUBLE_SPHERE_CAMERA_CAL";
        case type_t::EQUIRECTANGULAR_CAMERA_CAL:
            return s << "EQUIRECTANGULAR_CAMERA_CAL";
        case type_t::LINEAR_CAMERA_CAL:
            return s << "LINEAR_CAMERA_CAL";
        case type_t::POLYNOMIAL_CAMERA_CAL:
            return s << "POLYNOMIAL_CAMERA_CAL";
        case type_t::SPHERICAL_CAMERA_CAL:
            return s << "SPHERICAL_CAMERA_CAL";
    }
    return s << "type_t::" << static_cast<int32_t>(option);
}

inline std::ostream& operator <<(std::ostream& s, const type_t& object)
{
    return s << object.value;
}

}  // namespace  sym

// Allow enum as an unordered_map key
// http://stackoverflow.com/a/18838036
namespace std {
template <>
struct hash<::sym::type_t> {
    typedef ::sym::type_t argument_type;
    typedef std::underlying_type<argument_type::option_t>::type underlying_type;
    std::size_t operator()(const argument_type& arg) const {
        std::hash<underlying_type> hasher;
        return hasher(static_cast<underlying_type>(arg.value));
    }
};
} // namespace std

#endif